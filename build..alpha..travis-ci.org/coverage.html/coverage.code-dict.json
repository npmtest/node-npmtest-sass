{"/home/travis/build/npmtest/node-npmtest-sass/test.js":"/* istanbul instrument in package npmtest_sass */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sass/lib.npmtest_sass.js":"/* istanbul instrument in package npmtest_sass */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_sass = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_sass = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-sass/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-sass && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_sass */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_sass\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_sass.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_sass.rollup.js'] =\n            local.assetsDict['/assets.npmtest_sass.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_sass.__dirname + '/lib.npmtest_sass.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sass/node_modules/sass/lib/sass.js":"\n// Sass - Core - Copyright TJ Holowaychuk <tj@vision-media.ca> (MIT Licensed)\n\n/**\n * Library version.\n */\n\nexports.version = '0.5.0'\n\n/**\n * Compiled sass cache.\n */\n \nvar cache = {}\n\n/**\n * Sass grammar tokens.\n */\n\nvar tokens = [\n  ['indent', /^\\n +/],\n  ['space', /^ +/],\n  ['nl', /^\\n/],\n  ['js', /^{(.*?)}/],\n  ['comment', /^\\/\\/(.*)/],\n  ['string', /^(?:'(.*?)'|\"(.*?)\")/],\n  ['variable', /^!([\\w\\-]+) *= *([^\\n]+)/], \n  ['variable.alternate', /^([\\w\\-]+): +([^\\n]+)/], \n  ['property.expand', /^=([\\w\\-]+) *([^\\n]+)/], \n  ['property', /^:([\\w\\-]+) *([^\\n]+)/], \n  ['continuation', /^&(.+)/],\n  ['mixin', /^\\+([\\w\\-]+)/],\n  ['selector', /^(.+)/]\n]\n\n/**\n * Vendor-specific expansion prefixes.\n */\n\nexports.expansions = ['-moz-', '-webkit-']\n\n/**\n * Tokenize the given _str_.\n *\n * @param  {string} str\n * @return {array}\n * @api private\n */\n\nfunction tokenize(str) {\n  var token, captures, stack = []\n  while (str.length) {\n    for (var i = 0, len = tokens.length; i < len; ++i)\n      if (captures = tokens[i][1].exec(str)) {\n        token = [tokens[i][0], captures],\n        str = str.replace(tokens[i][1], '')\n        break\n      }\n    if (token)\n      stack.push(token),\n      token = null\n    else \n      throw new Error(\"SyntaxError: near `\" + str.slice(0, 25).replace('\\n', '\\\\n') + \"'\")\n  }\n  return stack\n}\n\n/**\n * Parse the given _tokens_, returning\n * and hash containing the properties below:\n *\n *   selectors: array of top-level selectors\n *   variables: hash of variables defined\n *\n * @param  {array} tokens\n * @return {hash}\n * @api private\n */\n\nfunction parse(tokens) {\n  var token, selector,\n      data = { variables: {}, mixins: {}, selectors: [] },\n      line = 1,\n      lastIndents = 0,\n      indents = 0\n  \n  /**\n   * Output error _msg_ in context to the current line.\n   */\n      \n  function error(msg) {\n    throw new Error('ParseError: on line ' + line + '; ' + msg)\n  }\n  \n  /**\n   * Reset parents until the indentation levels match.\n   */\n  \n  function reset() {\n    if (indents === 0) \n      return selector = null\n    while (lastIndents-- > indents)\n      selector = selector.parent\n  }\n\n  /**\n   * Replaces variables and literal javascript in the input.\n   */\n\n  function performSubstitutions(input) {\n    return input.replace(/!([\\w\\-]+)/g, function(orig, name){\n      return data.variables[name] || orig\n    })\n    .replace(/\\{(.*?)\\}/g, function(_, js){\n      with (data.variables){ return eval(js) }\n    })\n  }\n  \n  // Parse tokens\n  \n  while (token = tokens.shift())\n    switch (token[0]) {\n      case 'mixin':\n        if (indents) {\n          var mixin = data.mixins[token[1][1]]\n          if (!mixin) error(\"mixin `\" + token[1][1] + \"' does not exist\")\n          selector.adopt(mixin.copy())\n        }\n        else\n          data.mixins[token[1][1]] = selector = new Selector(token[1][1], null, 'mixin')\n        break\n      case 'continuation':\n        reset()\n        selector = new Selector(token[1][1], selector, 'continuation')\n        break\n      case 'selector':\n        reset()\n        selector = new Selector(token[1][1], selector)\n        if (!selector.parent) \n          data.selectors.push(selector)\n        break\n      case 'property':\n        reset()\n        if (!selector) error('properties must be nested within a selector')\n        var val = performSubstitutions(token[1][2])\n        selector.properties.push(new Property(token[1][1], val))\n        break\n      case 'property.expand':\n        exports.expansions.forEach(function(prefix){\n          tokens.unshift(['property', [, prefix + token[1][1], token[1][2]]])\n        })\n        break\n      case 'variable':\n      case 'variable.alternate':\n        var val = performSubstitutions(token[1][2])\n        data.variables[token[1][1]] = val\n        break\n      case 'js':\n        with (data.variables){ eval(token[1][1]) }\n        break\n      case 'nl':\n        ++line, indents = 0\n        break\n      case 'comment':\n        break\n      case 'indent':\n        ++line\n        lastIndents = indents,\n        indents = (token[1][0].length - 1) / 2\n        if (indents > lastIndents &&\n            indents - 1 > lastIndents)\n              error('invalid indentation, to much nesting')\n    }\n  return data\n}\n\n/**\n * Compile _selectors_ to a string of css.\n *\n * @param  {array} selectors\n * @return {string}\n * @api private\n */\n\nfunction compile(selectors) {\n  return selectors.join('\\n')\n}\n\n/**\n * Collect data by parsing _sass_.\n * Returns a hash containing the following properties:\n *\n *   selectors: array of top-level selectors\n *   variables: hash of variables defined\n *\n * @param  {string} sass\n * @return {hash}\n * @api public\n */\n\nexports.collect = function(sass) {\n  return parse(tokenize(sass))\n}\n\n/**\n * Render a string of _sass_.\n *\n * Options:\n *   \n *   - filename  Optional filename to aid in error reporting\n *   - cache     Optional caching of compiled content. Requires \"filename\" option\n *\n * @param  {string} sass\n * @param  {object} options\n * @return {string}\n * @api public\n */\n\nexports.render = function(sass, options) {\n  options = options || {}\n  if (options.cache && !options.filename)\n    throw new Error('filename option must be passed when cache is enabled')\n  if (options.cache)\n    return cache[options.filename]\n      ? cache[options.filename]\n      : cache[options.filename] = compile(exports.collect(sass).selectors)\n  return compile(exports.collect(sass).selectors)\n}\n\n// --- Selector\n\n/**\n * Initialize a selector with _string_ and\n * optional _parent_.\n *\n * @param  {string} string\n * @param  {Selector} parent\n * @param  {string} type\n * @api private\n */\n\nfunction Selector(string, parent, type) {\n  this.string = string\n  if (parent) {\n    parent.adopt(this)\n  } else {\n    parent = null\n  }\n  this.properties = []\n  this.children = []\n  this.type = type\n  if (type) this[type] = true\n}\n\n/**\n * Return a copy of this selector.  Children and properties will be recursively\n * copied.\n *\n * @return {Selector}\n * @api private\n */\n\nSelector.prototype.copy = function() {\n  var copy = new Selector(this.string, this.parent, this.type)\n  copy.properties = this.properties.map(function(property) {\n    return property.copy()\n  })\n  this.children.map(function(child) {\n    copy.adopt(child.copy())\n  })\n  return copy\n}\n\n/**\n * Sets this selector to have no parent.\n *\n * @api private\n */\n\nSelector.prototype.orphan = function() {\n  if (this.parent) {\n    var index = this.parent.children.indexOf(this)\n    if (index !== -1) {\n      this.parent.children.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Set another selector as one of this selector's children.\n *\n * @api private\n */\n\nSelector.prototype.adopt = function(selector) {\n  selector.orphan()\n  selector.parent = this\n  this.children.push(selector)\n}\n\n/**\n * Return selector string.\n *\n * @return {string}\n * @api private\n */\n\nSelector.prototype.selector = function() {\n  var selector = this.string\n  if (this.parent)\n    selector = this.continuation\n      ? this.parent.selector() + selector\n      : this.mixin\n        ? this.parent.selector()\n        : this.parent.selector() + ' ' + selector\n  return selector\n}\n\n/**\n * Return selector and nested selectors as CSS.\n *\n * @return {string}\n * @api private\n */\n\nSelector.prototype.toString = function() {\n  return (this.properties.length\n      ? this.selector() + ' {\\n' + this.properties.join('\\n') + '}\\n'\n      : '') + this.children.join('')\n}\n\n// --- Property\n\n/**\n * Initialize property with _name_ and _val_.\n *\n * @param  {string} name\n * @param  {string} val\n * @api private\n */\n\nfunction Property(name, val) {\n  this.name = name\n  this.val = val\n}\n\n/**\n * Return a copy of this property.\n *\n * @return {Property}\n * @api private\n */\n\nProperty.prototype.copy = function() {\n  return new Property(this.name, this.val);\n}\n\n/**\n * Return CSS string representing a property.\n *\n * @return {string}\n * @api private\n */\n\nProperty.prototype.toString = function() {\n  return '  ' + this.name + ': ' + this.val + ';'\n}\n","/home/travis/build/npmtest/node-npmtest-sass/node_modules/sass/lib/._sass.js":"\u0000\u0005\u0016\u0007\u0000\u0002\u0000\u0000Mac OS X        \u0000\u0002\u0000\u0000\u0000\t\u0000\u0000\u00002\u0000\u0000\u0000�\u0000\u0000\u0000\u0002\u0000\u0000\u0000�\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000ATTR\u0000�@�\u0000\u0000\u0000�\u0000\u0000\u0000�\u0000\u0000\u0000\"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000�\u0000\u0000\u0000\"\u0000\u0000\u0015com.macromates.caret\u0000{\n    column = 24;\n    line = 7;\n}","/home/travis/build/npmtest/node-npmtest-sass/node_modules/sass/spec/node.js":"\nrequire.paths.unshift('spec', 'spec/lib', 'lib')\nrequire('jspec')\nsass = require('sass')\n\nJSpec\n  .exec('spec/spec.core.js')\n  .run({ reporter: JSpec.reporters.Terminal, fixturePath: 'spec/fixtures', failuresOnly: true })\n  .report()\n","/home/travis/build/npmtest/node-npmtest-sass/node_modules/sass/spec/spec.core.js":"\ndescribe 'Sass'\n  before\n    render = function(path, options) {\n      return sass.render(fixture(path + '.sass'), options)\n    }\n    \n    expected = function(path) {\n      return fixture(path + '.css')\n    }\n    \n    assert = function(path, options) {\n      render(path, options).should.eql expected(path)\n    }\n  end\n  \n  describe '.version'\n    it 'should be a triplet'\n      sass.version.should.match(/^\\d+\\.\\d+\\.\\d+$/)\n    end\n  end\n  \n  describe '.render()'\n    describe 'with \"cache\" enabled'\n      describe 'without \"filename\"'\n        it 'should throw an error'\n          -{ assert('selectors', { cache: true }) }.should.throw_error 'filename option must be passed when cache is enabled'\n        end\n      end\n      \n      describe 'with \"filename\"'\n        it 'should still work'\n          assert('selectors', { cache: true, filename: 'style.sass' })\n        end\n      end\n    end\n  \n    it 'should support complex selectors'\n      assert('selectors')\n    end\n    \n    describe '// ...'\n      it 'should be a sass-specific comment'\n        assert('comment')\n      end\n    end\n    \n    describe '& ...'\n      it 'should continue a selector'\n        assert('continuation')\n      end\n    end\n  \n    describe '{...}'\n      it 'should have access to variables'\n        assert('literal')\n      end\n    end\n    \n    describe ':key val'\n      it 'should define a property'\n        assert('properties')\n      end\n      \n      describe 'when nested'\n        it 'should traverse correctly'\n          assert('properties.nested')\n        end\n        \n        describe 'incorrectly'\n          it 'should throw an error'\n            try { assert('properties.nested.invalid') }\n            catch (e) {\n              e.message.should.eql 'ParseError: on line 3; invalid indentation, to much nesting'\n            }\n          end\n        end\n      end\n      \n      describe 'when at the top level'\n        it 'should throw an error'\n          try { assert('properties.invalid') }\n          catch (e) {\n            e.message.should.eql 'ParseError: on line 1; properties must be nested within a selector'\n          }\n        end\n      end\n    end\n    \n    describe '=:key val'\n      it 'should expand to -{moz, webkit}-border-radius'\n        assert('properties.expand')\n      end\n    end\n    \n    describe '!key = val'\n      it 'should define a variable'\n        assert('variables.regular')\n      end\n    end\n    \n    describe '!key1 = !key2'\n      it 'should reference a previously-defined variable'\n        assert('variables.dependent')\n      end\n    end\n    \n    describe 'key: val'\n      it 'should define a variable'\n        assert('variables.alternate')\n      end\n    end\n  end\n  \n  describe '+mixin'\n    it 'should create a mixin'\n      assert('mixin')\n    end\n    \n    it 'should create multiple appropriate mixins'\n      assert('mixin.multiple')\n    end\n    \n    describe 'when the mixin does not exist'\n      try { assert('mixin.undefined') }\n      catch (e) {\n        e.message.should.eql 'ParseError: on line 2; mixin `large\\' does not exist'\n      }\n    end\n  end\n  \n  describe '.collect()'\n    it 'should return variables defined'\n      var collected = sass.collect(fixture('collect.sass'))\n      collected.variables.should.eql { red: '#ff0000', black: '#000' }\n    end\n    \n    it 'should return mixins defined'\n      var collected = sass.collect(fixture('mixin.sass'))\n      collected.mixins.should.have_property 'large'\n      collected.mixins.should.have_property 'striped'\n    end\n  end\nend\n","/home/travis/build/npmtest/node-npmtest-sass/node_modules/sass/spec/lib/jspec.growl.js":"\n// JSpec - Growl - Copyright TJ Holowaychuk <tj@vision-media.ca> (MIT Licensed)\n\n;(function(){\n  \n  Growl = {\n    \n    // --- Version\n    \n    version: '1.0.0',\n    \n    /**\n     * Execute the given _cmd_, returning an array of lines from stdout.\n     *\n     * Examples:\n     *\n     *   Growl.exec('growlnotify', '-m', msg)\n     *\n     * @param  {string ...} cmd\n     * @return {array}\n     * @api public\n     */\n\n    exec: function(cmd) {\n      var lines = [], line\n      with (JavaImporter(java.lang, java.io)) {\n        var proccess = Runtime.getRuntime().exec(Array.prototype.slice.call(arguments))\n        var stream = new DataInputStream(proccess.getInputStream())\n        while (line = stream.readLine())\n          lines.push(line + '')\n        stream.close()    \n      }\n      return lines\n    },\n    \n    /**\n     * Return the extension of the given _path_ or null.\n     *\n     * @param  {string} path\n     * @return {string}\n     * @api private\n     */\n    \n    extname: function(path) {\n      return path.lastIndexOf('.') != -1 ? \n        path.slice(path.lastIndexOf('.') + 1, path.length) :\n          null\n    },\n\n    /**\n     * Version of the 'growlnotify' binary.\n     *\n     * @return {string}\n     * @api private\n     */\n\n    binVersion: function() {\n      try { return this.exec('growlnotify', '-v')[0].split(' ')[1] } catch (e) {}\n    },\n\n    /**\n     * Send growl notification _msg_ with _options_.\n     *\n     * Options:\n     *\n     *  - title   Notification title\n     *  - sticky  Make the notification stick (defaults to false)\n     *  - name    Application name (defaults to growlnotify)\n     *  - image\n     *    - path to an icon sets --iconpath\n     *    - path to an image sets --image\n     *    - capitalized word sets --appIcon\n     *    - filename uses extname as --icon\n     *    - otherwise treated as --icon\n     *\n     * Examples:\n     *\n     *   Growl.notify('New email')\n     *   Growl.notify('5 new emails', { title: 'Thunderbird' })\n     *\n     * @param {string} msg\n     * @param {options} hash\n     * @api public\n     */\n\n    notify: function(msg, options) {\n      options = options || {}\n      var args = ['growlnotify', '-m', msg]\n      if (!this.binVersion()) throw new Error('growlnotify executable is required')\n      if (image = options.image) {\n        var flag, ext = this.extname(image)\n        flag = flag || ext == 'icns' && 'iconpath'\n        flag = flag || /^[A-Z]/.test(image) && 'appIcon'\n        flag = flag || /^png|gif|jpe?g$/.test(ext) && 'image'\n        flag = flag || ext && (image = ext) && 'icon'\n        flag = flag || 'icon'\n        args.push('--' + flag, image)\n      }\n      if (options.sticky) args.push('--sticky')\n      if (options.name) args.push('--name', options.name)\n      if (options.title) args.push(options.title)\n      this.exec.apply(this, args)\n    }\n  }\n  \n  JSpec.include({\n    name: 'Growl',\n    reporting: function(options){\n      var stats = JSpec.stats\n      if (stats.failures) Growl.notify('failed ' + stats.failures + ' assertions', { title: 'JSpec'})\n      else Growl.notify('passed ' + stats.passes + ' assertions', { title: 'JSpec' })\n    }\n  })\n  \n})()","/home/travis/build/npmtest/node-npmtest-sass/node_modules/sass/spec/lib/jspec.jquery.js":"\n// JSpec - jQuery - Copyright TJ Holowaychuk <tj@vision-media.ca> (MIT Licensed)\n\nJSpec\n.requires('jQuery', 'when using jspec.jquery.js')\n.include({\n  name: 'jQuery',\n  \n  // --- Initialize\n  \n  init : function() {\n    jQuery.ajaxSetup({ async: false })\n  },\n  \n  // --- Utilities\n  \n  utilities : {\n    element:  jQuery,\n    elements: jQuery,\n    sandbox : function() {\n      return jQuery('<div class=\"sandbox\"></div>')\n    }\n  },\n  \n  // --- Matchers\n  \n  matchers : {    \n    have_tag      : \"jQuery(expected, actual).length === 1\",\n    have_one      : \"alias have_tag\",\n    have_tags     : \"jQuery(expected, actual).length > 1\",\n    have_many     : \"alias have_tags\",\n    have_any      : \"alias have_tags\",\n    have_child    : \"jQuery(actual).children(expected).length === 1\",\n    have_children : \"jQuery(actual).children(expected).length > 1\",\n    have_text     : \"jQuery(actual).text() === expected\",\n    have_value    : \"jQuery(actual).val() === expected\",\n    be_enabled    : \"!jQuery(actual).attr('disabled')\",\n    have_class    : \"jQuery(actual).hasClass(expected)\",\n    be_animated   : \"jQuery(actual).queue().length > 0\",        \n        \n    be_visible : function(actual) {\n      return jQuery(actual).css('display') != 'none' &&\n             jQuery(actual).css('visibility') != 'hidden' &&\n             jQuery(actual).attr('type') != 'hidden'\n    },\n    \n    be_hidden : function(actual) {\n      return !JSpec.does(actual, 'be_visible')\n    },\n    \n    have_classes : function(actual) {\n      return !JSpec.any(JSpec.toArray(arguments, 1), function(arg){\n        return !JSpec.does(actual, 'have_class', arg)\n      })\n    },\n\n    have_attr : function(actual, attr, value) {\n      return value ? jQuery(actual).attr(attr) == value:\n                     jQuery(actual).attr(attr)\n    },\n    \n    have_event_handlers : function(actual, expected) {\n      return jQuery(actual).data('events') ?\n        jQuery(actual).data('events').hasOwnProperty(expected) :\n          false\n    },\n    \n    'be disabled selected checked' : function(attr) {\n      return 'jQuery(actual).attr(\"' + attr + '\")'\n    },\n    \n    'have type id title alt href src sel rev name target' : function(attr) {\n      return function(actual, value) {\n        return JSpec.does(actual, 'have_attr', attr, value)\n      }\n    }\n  }\n})\n\n","/home/travis/build/npmtest/node-npmtest-sass/node_modules/sass/spec/lib/jspec.js":"\n// JSpec - Core - Copyright TJ Holowaychuk <tj@vision-media.ca> (MIT Licensed)\n\n;(function(){\n\n  JSpec = {\n    version   : '4.3.2',\n    assert    : true,\n    cache     : {},\n    suites    : [],\n    modules   : [],\n    allSuites : [],\n\t\tsharedBehaviors: [],\n    matchers  : {},\n    stubbed   : [],\n    options   : {},\n    request   : 'XMLHttpRequest' in this ? XMLHttpRequest : null,\n    stats     : { specs: 0, assertions: 0, failures: 0, passes: 0, specsFinished: 0, suitesFinished: 0 },\n\n    /**\n     * Default context in which bodies are evaluated.\n     *\n     * Replace context simply by setting JSpec.context\n     * to your own like below:\n     *\n     * JSpec.context = { foo : 'bar' }\n     *\n     * Contexts can be changed within any body, this can be useful\n     * in order to provide specific helper methods to specific suites.\n     *\n     * To reset (usually in after hook) simply set to null like below:\n     *\n     * JSpec.context = null\n     *\n     */\n\n     defaultContext : {\n      \n      /**\n       * Return an object used for proxy assertions. \n       * This object is used to indicate that an object\n       * should be an instance of _object_, not the constructor\n       * itself.\n       *\n       * @param  {function} constructor\n       * @return {hash}\n       * @api public\n       */\n      \n      an_instance_of : function(constructor) {\n        return { an_instance_of : constructor }\n      },\n      \n      /**\n       * Load fixture at _path_.\n       *\n       * Fixtures are resolved as:\n       *\n       *  - <path>\n       *  - <path>.html\n       *\n       * @param  {string} path\n       * @return {string}\n       * @api public\n       */\n      \n      fixture : function(path) {\n        if (JSpec.cache[path]) return JSpec.cache[path]\n        return JSpec.cache[path] = \n          JSpec.tryLoading(JSpec.options.fixturePath + '/' + path) ||\n          JSpec.tryLoading(JSpec.options.fixturePath + '/' + path + '.html')\n      },\n      \n      /**\n       * Load json fixture at _path_.\n       *\n       * JSON fixtures are resolved as:\n       *\n       *  - <path>\n       *  - <path>.json\n       *\n       * @param  {string} path\n       * @return {object}\n       * @api public\n       */\n      \n      json_fixture: function(path) {\n        if (!JSpec.cache['json:' + path])\n          JSpec.cache['json:' + path] =\n            JSpec.tryLoading(JSpec.options.fixturePath + '/' + path) ||\n            JSpec.tryLoading(JSpec.options.fixturePath + '/' + path + '.json')\n        try {\n          return eval('(' + JSpec.cache['json:' + path] + ')')\n        } catch (e) {\n          throw 'json_fixture(\"' + path + '\"): ' + e\n        }\n      }\n    },\n\n    // --- Objects\n    \n    reporters : {\n      \n      /**\n       * Report to server.\n       * \n       * Options:\n       *  - uri           specific uri to report to.\n       *  - verbose       weither or not to output messages\n       *  - failuresOnly  output failure messages only\n       *\n       * @api public\n       */\n      \n      Server : function(results, options) {\n        var uri = options.uri || 'http://' + window.location.host + '/results'\n        JSpec.post(uri, {\n          stats: JSpec.stats,\n          options: options,\n          results: map(results.allSuites, function(suite) {\n            if (suite.isExecutable())\n              return {\n                description: suite.description,\n                specs: map(suite.specs, function(spec) {\n                  return {\n                    description: spec.description,\n                    message: !spec.passed() ? spec.failure().message : null,\n                    status: spec.requiresImplementation() ? 'pending' :\n                              spec.passed() ? 'pass' :\n                                'fail',\n                    assertions: map(spec.assertions, function(assertion){\n                      return {\n                        passed: assertion.passed  \n                      }\n                    })\n                  }\n                })\n              }\n          })\n        })\n  \t\t\tif ('close' in main) main.close()\n      },\n\n      /**\n       * Default reporter, outputting to the DOM.\n       *\n       * Options:\n       *   - reportToId    id of element to output reports to, defaults to 'jspec'\n       *   - failuresOnly  displays only suites with failing specs\n       *\n       * @api public\n       */\n\n      DOM : function(results, options) {\n        var id = option('reportToId') || 'jspec',\n            report = document.getElementById(id),\n            failuresOnly = option('failuresOnly'),\n            classes = results.stats.failures ? 'has-failures' : ''\n        if (!report) throw 'JSpec requires the element #' + id + ' to output its reports'\n        \n        function bodyContents(body) {\n          return JSpec.\n            escape(JSpec.contentsOf(body)).\n            replace(/^ */gm, function(a){ return (new Array(Math.round(a.length / 3))).join(' ') }).\n            replace(/\\r\\n|\\r|\\n/gm, '<br/>')\n        }\n        \n        report.innerHTML = '<div id=\"jspec-report\" class=\"' + classes + '\"><div class=\"heading\"> \\\n        <span class=\"passes\">Passes: <em>' + results.stats.passes + '</em></span>                \\\n        <span class=\"failures\">Failures: <em>' + results.stats.failures + '</em></span>          \\\n        <span class=\"passes\">Duration: <em>' + results.duration + '</em> ms</span>          \\\n        </div><table class=\"suites\">' + map(results.allSuites, function(suite) {\n          var displaySuite = failuresOnly ? suite.ran && !suite.passed() : suite.ran\n          if (displaySuite && suite.isExecutable())\n            return '<tr class=\"description\"><td colspan=\"2\">' + escape(suite.description) + '</td></tr>' +\n              map(suite.specs, function(i, spec) {\n                return '<tr class=\"' + (i % 2 ? 'odd' : 'even') + '\">' +\n                  (spec.requiresImplementation() ?\n                    '<td class=\"requires-implementation\" colspan=\"2\">' + escape(spec.description) + '</td>' :\n                      (spec.passed() && !failuresOnly) ?\n                        '<td class=\"pass\">' + escape(spec.description)+ '</td><td>' + spec.assertionsGraph() + '</td>' :\n                          !spec.passed() ?\n                            '<td class=\"fail\">' + escape(spec.description) + \n  \t\t\t\t\t\t\t\t\t\t\t\t\tmap(spec.failures(), function(a){ return '<em>' + escape(a.message) + '</em>' }).join('') +\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t'</td><td>' + spec.assertionsGraph() + '</td>' :\n                              '') +\n                  '<tr class=\"body\"><td colspan=\"2\"><pre>' + bodyContents(spec.body) + '</pre></td></tr>'\n              }).join('') + '</tr>'\n        }).join('') + '</table></div>'\n      },\n      \n      /**\n       * Terminal reporter.\n       *\n       * @api public\n       */\n       \n       Terminal : function(results, options) {\n         var failuresOnly = option('failuresOnly')\n         print(color(\"\\n Passes: \", 'bold') + color(results.stats.passes, 'green') + \n               color(\" Failures: \", 'bold') + color(results.stats.failures, 'red') +\n               color(\" Duration: \", 'bold') + color(results.duration, 'green') + \" ms \\n\")\n              \n         function indent(string) {\n           return string.replace(/^(.)/gm, '  $1')\n         }\n         \n         each(results.allSuites, function(suite) {\n           var displaySuite = failuresOnly ? suite.ran && !suite.passed() : suite.ran\n            if (displaySuite && suite.isExecutable()) {\n              print(color(' ' + suite.description, 'bold'))\n              each(suite.specs, function(spec){\n                var assertionsGraph = inject(spec.assertions, '', function(graph, assertion){\n                  return graph + color('.', assertion.passed ? 'green' : 'red')\n                })\n                if (spec.requiresImplementation())\n                  print(color('  ' + spec.description, 'blue') + assertionsGraph)\n                else if (spec.passed() && !failuresOnly)\n                  print(color('  ' + spec.description, 'green') + assertionsGraph)\n                else if (!spec.passed())\n                  print(color('  ' + spec.description, 'red') + assertionsGraph + \n                        \"\\n\" + indent(map(spec.failures(), function(a){ return a.message }).join(\"\\n\")) + \"\\n\")\n              })\n              print(\"\")\n            }\n         })\n         \n         quit(results.stats.failures)\n       }\n    },\n    \n    Assertion : function(matcher, actual, expected, negate) {\n      extend(this, {\n        message: '',\n        passed: false,\n        actual: actual,\n        negate: negate,\n        matcher: matcher,\n        expected: expected,\n        \n        // Report assertion results\n        \n        report : function() {\n          if (JSpec.assert) \n            this.passed ? JSpec.stats.passes++ : JSpec.stats.failures++\n          return this\n        },\n        \n        // Run the assertion\n        \n        run : function() {\n          // TODO: remove unshifting \n          expected.unshift(actual)\n          this.result = matcher.match.apply(this, expected)\n          this.passed = negate ? !this.result : this.result\n          if (!this.passed) this.message = matcher.message.call(this, actual, expected, negate, matcher.name)\n          return this\n        }\n      })\n    },\n    \n    ProxyAssertion : function(object, method, times, negate) {\n      var self = this,\n          old = object[method]\n      \n      // Proxy\n      \n      object[method] = function(){\n        var args = toArray(arguments),\n            result = old.apply(object, args)\n        self.calls.push({ args : args, result : result })\n        return result\n      }\n      \n      // Times\n      \n      this.times = {\n        once  : 1,\n        twice : 2\n      }[times] || times || 1\n      \n      extend(this, {\n        calls: [],\n        message: '',\n        defer: true,\n        passed: false,\n        negate: negate,\n        object: object,\n        method: method,\n        \n        // Proxy return value\n        \n        and_return : function(result) {\n          this.expectedResult = result\n          return this\n        },\n        \n        // Proxy arguments passed\n        \n        with_args : function() {\n          this.expectedArgs = toArray(arguments)\n          return this\n        },\n        \n        // Check if any calls have failing results\n        \n        anyResultsFail : function() {\n          return any(this.calls, function(call){\n            return self.expectedResult.an_instance_of ?\n                     call.result.constructor != self.expectedResult.an_instance_of:\n                       !equal(self.expectedResult, call.result)\n          })\n        },\n        \n        // Check if any calls have passing results\n        \n        anyResultsPass : function() {\n          return any(this.calls, function(call){\n            return self.expectedResult.an_instance_of ?\n                     call.result.constructor == self.expectedResult.an_instance_of:\n                       equal(self.expectedResult, call.result)\n          })\n        },\n        \n        // Return the passing result\n        \n        passingResult : function() {\n          return this.anyResultsPass().result\n        },\n\n        // Return the failing result\n        \n        failingResult : function() {\n          return this.anyResultsFail().result\n        },\n        \n        // Check if any arguments fail\n        \n        anyArgsFail : function() {\n          return any(this.calls, function(call){\n            return any(self.expectedArgs, function(i, arg){\n              if (arg == null) return call.args[i] == null\n              return arg.an_instance_of ?\n                       call.args[i].constructor != arg.an_instance_of:\n                         !equal(arg, call.args[i])\n                       \n            })\n          })\n        },\n        \n        // Check if any arguments pass\n        \n        anyArgsPass : function() {\n          return any(this.calls, function(call){\n            return any(self.expectedArgs, function(i, arg){\n              return arg.an_instance_of ?\n                       call.args[i].constructor == arg.an_instance_of:\n                         equal(arg, call.args[i])\n                       \n            })\n          })\n        },\n        \n        // Return the passing args\n        \n        passingArgs : function() {\n          return this.anyArgsPass().args\n        },\n                \n        // Return the failing args\n        \n        failingArgs : function() {\n          return this.anyArgsFail().args\n        },\n        \n        // Report assertion results\n        \n        report : function() {\n          if (JSpec.assert) \n            this.passed ? ++JSpec.stats.passes : ++JSpec.stats.failures\n          return this\n        },\n        \n        // Run the assertion\n                \n        run : function() {\n          var methodString = 'expected ' + object.toString() + '.' + method + '()' + (negate ? ' not' : '' )\n          \n          function times(n) {\n            return n > 2 ?  n + ' times' : { 1: 'once', 2: 'twice' }[n]\n          }\n          \n          if (this.expectedResult != null && (negate ? this.anyResultsPass() : this.anyResultsFail()))\n            this.message = methodString + ' to return ' + puts(this.expectedResult) + \n              ' but ' + (negate ? 'it did' : 'got ' + puts(this.failingResult())) \n\n          if (this.expectedArgs && (negate ? !this.expectedResult && this.anyArgsPass() : this.anyArgsFail()))\n            this.message = methodString + ' to be called with ' + puts.apply(this, this.expectedArgs) +\n             ' but was' + (negate ? '' : ' called with ' + puts.apply(this, this.failingArgs()))\n\n          if (negate ? !this.expectedResult && !this.expectedArgs && this.calls.length >= this.times : this.calls.length != this.times)\n            this.message = methodString + ' to be called ' + times(this.times) + \n            ', but ' +  (this.calls.length == 0 ? ' was not called' : ' was called ' + times(this.calls.length))\n                \n          if (!this.message.length) \n            this.passed = true\n          \n          return this\n        }\n      })\n    },\n      \n    /**\n     * Specification Suite block object.\n     *\n     * @param {string} description\n     * @param {function} body\n     * @api private\n     */\n\n    Suite : function(description, body, isShared) {\n      var self = this\n      extend(this, {\n        body: body,\n        description: description,\n        suites: [],\n\t\t\t\tsharedBehaviors: [],\n        specs: [],\n        ran: false,\n\t\t\t\tshared: isShared, \n\t\t\t\thooks: { \t'before' : [], 'after' : [], \n\t\t\t\t\t\t\t\t\t'before_each' : [], 'after_each' : [],\n\t\t\t\t\t\t\t\t\t'before_nested' : [], 'after_nested' : []},\n        \n\t\t\t\t// Add a spec to the suite\n\n        addSpec : function(description, body) {\n          var spec = new JSpec.Spec(description, body)\n          this.specs.push(spec)\n          JSpec.stats.specs++ // TODO: abstract\n          spec.suite = this\n        },\n\n        // Add a before hook to the suite\n\n        addBefore : function(options, body) {\n\t\t\t\t\tbody.options = options || {}\n          this.befores.push(body)\n        },\n\n        // Add an after hook to the suite\n\n        addAfter : function(options, body) {\n\t\t\t\t\tbody.options = options || {}\n          this.afters.unshift(body)\n        },\n\n        // Add a hook to the suite\n \n        addHook : function(hook, body) {\n          this.hooks[hook].push(body)\n        },\n\n        // Add a nested suite\n\n        addSuite : function(description, body, isShared) {\n          var suite = new JSpec.Suite(description, body, isShared)\n          JSpec.allSuites.push(suite)\n          suite.name = suite.description\n          suite.description = this.description + ' ' + suite.description\n          this.suites.push(suite)\n          suite.suite = this\n        },\n\n\t\t\t\t// Invoke a hook in context to this suite\n\n        hook : function(hook) {\n\t\t\t\t\tif (hook != 'before' && hook != 'after')\t\n          \tif (this.suite) this.suite.hook(hook)\n\n          each(this.hooks[hook], function(body) {\n            JSpec.evalBody(body, \"Error in hook '\" + hook + \"', suite '\" + self.description + \"': \")\n          })\n        },\n\t\t\t\t\n        // Check if nested suites are present\n\n        hasSuites : function() {\n          return this.suites.length  \n        },\n\n        // Check if this suite has specs\n\n        hasSpecs : function() {\n          return this.specs.length\n        },\n\n        // Check if the entire suite passed\n\n        passed : function() {\n          return !any(this.specs, function(spec){\n            return !spec.passed() \n          })\n        },\n\n\t\t\t\tisShared : function(){\n\t\t\t\t\treturn this.shared\n\t\t\t\t},\n\n\t\t\t\tisExecutable : function() {\n\t\t\t\t\treturn !this.isShared() && this.hasSpecs()\n\t\t\t\t}\n      })\n    },\n    \n    /**\n     * Specification block object.\n     *\n     * @param {string} description\n     * @param {function} body\n     * @api private\n     */\n\n    Spec : function(description, body) {\n      extend(this, {\n        body: body,\n        description: description,\n        assertions: [],\n        \n        // Add passing assertion\n        \n        pass : function(message) {\n          this.assertions.push({ passed: true, message: message })\n          if (JSpec.assert) ++JSpec.stats.passes\n        },\n        \n        // Add failing assertion\n        \n        fail : function(message) {\n          this.assertions.push({ passed: false, message: message })\n          if (JSpec.assert) ++JSpec.stats.failures\n        },\n                \n        // Run deferred assertions\n        \n        runDeferredAssertions : function() {\n          each(this.assertions, function(assertion){\n            if (assertion.defer) assertion.run().report(), hook('afterAssertion', assertion)\n          })\n        },\n        \n        // Find first failing assertion\n\n        failure : function() {\n          return find(this.assertions, function(assertion){\n            return !assertion.passed\n          })\n        },\n\n        // Find all failing assertions\n\n        failures : function() {\n          return select(this.assertions, function(assertion){\n            return !assertion.passed\n          })\n        },\n\n        // Weither or not the spec passed\n\n        passed : function() {\n          return !this.failure()\n        },\n\n        // Weither or not the spec requires implementation (no assertions)\n\n        requiresImplementation : function() {\n          return this.assertions.length == 0\n        },\n\n        // Sprite based assertions graph\n\n        assertionsGraph : function() {\n          return map(this.assertions, function(assertion){\n            return '<span class=\"assertion ' + (assertion.passed ? 'passed' : 'failed') + '\"></span>'\n          }).join('')\n        }\n      })\n    },\n    \n    Module : function(methods) {\n      extend(this, methods)\n    },\n    \n    JSON : {\n      \n      /**\n       * Generic sequences.\n       */\n      \n      meta : {\n        '\\b' : '\\\\b',\n        '\\t' : '\\\\t',\n        '\\n' : '\\\\n',\n        '\\f' : '\\\\f',\n        '\\r' : '\\\\r',\n        '\"'  : '\\\\\"',\n        '\\\\' : '\\\\\\\\'\n      },\n      \n      /**\n       * Escapable sequences.\n       */\n      \n      escapable : /[\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n      \n      /**\n       * JSON encode _object_.\n       *\n       * @param  {mixed} object\n       * @return {string}\n       * @api private\n       */\n       \n      encode : function(object) {\n        var self = this\n        if (object == undefined || object == null) return 'null'\n        if (object === true) return 'true'\n        if (object === false) return 'false'\n        switch (typeof object) {\n          case 'number': return object\n          case 'string': return this.escapable.test(object) ?\n            '\"' + object.replace(this.escapable, function (a) {\n              return typeof self.meta[a] === 'string' ? self.meta[a] :\n                '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4)\n            }) + '\"' :\n            '\"' + object + '\"'\n          case 'object':  \n            if (object.constructor == Array)\n              return '[' + map(object, function(val){\n                return self.encode(val)\n              }).join(', ') + ']'\n            else if (object)\n              return '{' + map(object, function(key, val){\n                return self.encode(key) + ':' + self.encode(val)\n              }).join(', ') + '}'\n        }\n        return 'null'\n      }\n    },\n    \n    // --- DSLs\n    \n    DSLs : {\n      snake : {\n        expect : function(actual){\n          return JSpec.expect(actual)\n        },\n\n        describe : function(description, body) {\n          return JSpec.currentSuite.addSuite(description, body, false)\n        },\n\n        it : function(description, body) {\n          return JSpec.currentSuite.addSpec(description, body)\n        },\n\n        before : function(body) {\n          return JSpec.currentSuite.addHook('before', body)\n        },\n \n        after : function(body) {\n          return JSpec.currentSuite.addHook('after', body)\n        },\n \n        before_each : function(body) {\n          return JSpec.currentSuite.addHook('before_each', body)\n        },\n \n        after_each : function(body) {\n          return JSpec.currentSuite.addHook('after_each', body)\n        },\n\n\t\t\t\tbefore_nested : function(body) {\n\t\t\t\t\treturn JSpec.currentSuite.addHook('before_nested', body)\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\tafter_nested : function(body){\n\t\t\t\t\treturn JSpec.currentSuite.addhook('after_nested', body)\n\t\t\t\t},\n        \n\t\t\t\tshared_behaviors_for : function(description, body){\n\t\t\t\t  return JSpec.currentSuite.addSuite(description, body, true)\n\t\t\t\t},\n\n        should_behave_like : function(description) {\n          return JSpec.shareBehaviorsOf(description)\n        }\n      }\n    },\n\n    // --- Methods\n    \n    /**\n     * Check if _value_ is 'stop'. For use as a\n     * utility callback function.\n     *\n     * @param  {mixed} value\n     * @return {bool}\n     * @api public\n     */\n    \n    haveStopped : function(value) {\n      return value === 'stop'\n    },\n    \n    /**\n     * Include _object_ which may be a hash or Module instance.\n     *\n     * @param  {hash, Module} object\n     * @return {JSpec}\n     * @api public\n     */\n    \n    include : function(object) {\n      var module = object.constructor == JSpec.Module ? object : new JSpec.Module(object)\n      this.modules.push(module)\n      if ('init' in module) module.init()\n      if ('utilities' in module) extend(this.defaultContext, module.utilities)\n      if ('matchers' in module) this.addMatchers(module.matchers)\n      if ('reporters' in module) extend(this.reporters, module.reporters)\n      if ('DSLs' in module)\n        each(module.DSLs, function(name, methods){\n          JSpec.DSLs[name] = JSpec.DSLs[name] || {}\n          extend(JSpec.DSLs[name], methods)\n        })\n      return this\n    },\n    \n    /**\n     * Add a module hook _name_, which is immediately\n     * called per module with the _args_ given. An array of\n     * hook return values is returned.\n     *\n     * @param  {name} string\n     * @param  {...} args\n     * @return {array}\n     * @api private\n     */\n    \n    hook : function(name, args) {\n      args = toArray(arguments, 1)\n      return inject(JSpec.modules, [], function(results, module){\n        if (typeof module[name] == 'function')\n          results.push(JSpec.evalHook(module, name, args))\n      })\n    },\n    \n    /**\n     * Eval _module_ hook _name_ with _args_. Evaluates in context\n     * to the module itself, JSpec, and JSpec.context.\n     *\n     * @param  {Module} module\n     * @param  {string} name\n     * @param  {array} args\n     * @return {mixed}\n     * @api private\n     */\n    \n    evalHook : function(module, name, args) {\n      hook('evaluatingHookBody', module, name)\n      return module[name].apply(module, args)\n    },\n    \n    /**\n     * Same as hook() however accepts only one _arg_ which is\n     * considered immutable. This function passes the arg\n     * to the first module, then passes the return value of the last\n     * module called, to the following module. \n     *\n     * @param  {string} name\n     * @param  {mixed} arg\n     * @return {mixed}\n     * @api private\n     */\n    \n    hookImmutable : function(name, arg) {\n      return inject(JSpec.modules, arg, function(result, module){\n        if (typeof module[name] == 'function')\n          return JSpec.evalHook(module, name, [result])\n      })\n    },\n    \n    /**\n     * Find a shared example suite by its description or name.\n     * First searches parent tree of suites for shared behavior\n     * before falling back to global scoped nested behaviors.\n     *\n     * @param  {string} description\n     * @return {Suite}\n     * @api private\n     */\n    \n    findSharedBehavior : function(description) {\n      var behavior\n      return (behavior = JSpec.findLocalSharedBehavior(description))\n        ? behavior\n        : JSpec.findGlobalSharedBehavior(description)\n    },\n\n    /**\n     * Find a shared example suite within the current suite's\n     * parent tree by its description or name.\n     *\n     * @param  {string} description\n     * @return {Suite}\n     * @api private\n     */\n     \n\t\tfindLocalSharedBehavior : function(description) {\n\t\t\tvar behavior,\n\t\t\t    currentSuite = JSpec.currentSuite.suite\n\t\t\twhile (currentSuite)\n\t\t\t\tif (behavior = find(currentSuite.suites, JSpec.suiteDescriptionPredicate(description)))\n\t\t\t\t  return behavior\n\t\t\t\telse\n\t\t\t\t  currentSuite = currentSuite.suite\n\t\t},\n\t\t\n    /**\n     * Find a shared example suite within the global\n     * scope by its description or name.\n     *\n     * @param  {string} description\n     * @return {Suite}\n     * @api private\n     */\n     \n\t\tfindGlobalSharedBehavior : function(description) {\n\t   return find(JSpec.suites, JSpec.suiteDescriptionPredicate(description))\n\t\t},\n    \n    /**\n     * Build a predicate that will match a suite based on name or description\n     *\n     * @param  {string} description\n     * @return {function}\n     * @api private\n     */\n     \n\t\tsuiteDescriptionPredicate : function(description) {\n\t\t\treturn function(suite){\n\t\t\t  return suite.name === description ||\n\t\t\t         suite.description === description\n\t\t\t}\n\t\t},\n\n    /**\n     * Share behaviors (specs) of the given suite with\n     * the current suite.\n     *\n     * @param  {string} description\n     * @api public\n     */\n    \n    shareBehaviorsOf : function(description) {\n      var suite = JSpec.findSharedBehavior(description)\n      if (suite)\n        JSpec.evalBody(suite.body)\n      else\n        throw new Error(\"failed to find shared behaviors named `\" + description + \"'\")\n    },\n    \n    \n    /**\n     * Convert arguments to an array.\n     *\n     * @param  {object} arguments\n     * @param  {int} offset\n     * @return {array}\n     * @api public\n     */\n    \n    toArray : function(arguments, offset) {\n      return Array.prototype.slice.call(arguments, offset || 0)\n    },\n    \n    /**\n     * Return ANSI-escaped colored string.\n     *\n     * @param  {string} string\n     * @param  {string} color\n     * @return {string}\n     * @api public\n     */\n    \n    color : function(string, color) {\n      if (option('disableColors')) {\n        return string\n      } else {\n        return \"\\u001B[\" + {\n         bold    : 1,\n         black   : 30,\n         red     : 31,\n         green   : 32,\n         yellow  : 33,\n         blue    : 34,\n         magenta : 35,\n         cyan    : 36,\n         white   : 37\n        }[color] + 'm' + string + \"\\u001B[0m\"\n      }\n    },\n    \n    /**\n     * Default matcher message callback.\n     *\n     * @api private\n     */\n    \n    defaultMatcherMessage : function(actual, expected, negate, name) {\n      return 'expected ' + puts(actual) + ' to ' + \n               (negate ? 'not ' : '') + \n                  name.replace(/_/g, ' ') +\n                    ' ' + (expected.length > 1 ?\n                      puts.apply(this, expected.slice(1)) :\n                        '')\n    },\n    \n    /**\n     * Normalize a matcher message.\n     *\n     * When no messge callback is present the defaultMatcherMessage\n     * will be assigned, will suffice for most matchers.\n     *\n     * @param  {hash} matcher\n     * @return {hash}\n     * @api public\n     */\n    \n    normalizeMatcherMessage : function(matcher) {\n      if (typeof matcher.message != 'function') \n        matcher.message = this.defaultMatcherMessage\n      return matcher\n    },\n    \n    /**\n     * Normalize a matcher body\n     * \n     * This process allows the following conversions until\n     * the matcher is in its final normalized hash state.\n     *\n     * - '==' becomes 'actual == expected'\n     * - 'actual == expected' becomes 'return actual == expected'\n     * - function(actual, expected) { return actual == expected } becomes \n     *   { match : function(actual, expected) { return actual == expected }}\n     *\n     * @param  {mixed} body\n     * @return {hash}\n     * @api public\n     */\n    \n    normalizeMatcherBody : function(body) {\n      var captures\n      switch (body.constructor) {\n        case String:\n          if (captures = body.match(/^alias (\\w+)/)) return JSpec.matchers[last(captures)]\n          if (body.length < 4) body = 'actual ' + body + ' expected'\n          return { match: function(actual, expected) { return eval(body) }}  \n          \n        case Function:\n          return { match: body }\n          \n        default:\n          return body\n      }\n    },\n    \n    /**\n     * Get option value. This method first checks if\n     * the option key has been set via the query string,\n     * otherwise returning the options hash value.\n     *\n     * @param  {string} key\n     * @return {mixed}\n     * @api public\n     */\n     \n     option : function(key) {\n       return (value = query(key)) !== null ? value :\n                JSpec.options[key] || null\n     },\n     \n     /**\n      * Check if object _a_, is equal to object _b_.\n      *\n      * @param  {object} a\n      * @param  {object} b\n      * @return {bool}\n      * @api private\n      */\n     \n     equal: function(a, b) {\n       if (typeof a != typeof b) return\n       if (a === b) return true\n       if (a instanceof RegExp)\n         return a.toString() === b.toString()\n       if (a instanceof Date)\n         return Number(a) === Number(b)\n       if (typeof a != 'object') return\n       if (a.length !== undefined)\n         if (a.length !== b.length) return\n         else\n           for (var i = 0, len = a.length; i < len; ++i)\n             if (!equal(a[i], b[i]))\n               return\n       for (var key in a)\n         if (!equal(a[key], b[key]))\n           return\n       return true\n     },\n\n    /**\n     * Return last element of an array.\n     *\n     * @param  {array} array\n     * @return {object}\n     * @api public\n     */\n\n    last : function(array) {\n      return array[array.length - 1]\n    },\n\n    /**\n     * Convert object(s) to a print-friend string.\n     *\n     * @param  {...} object\n     * @return {string}\n     * @api public\n     */\n\n    puts : function(object) {\n      if (arguments.length > 1)\n        return map(toArray(arguments), function(arg){\n          return puts(arg)\n        }).join(', ')\n      if (object === undefined) return 'undefined'\n      if (object === null) return 'null'\n      if (object === true) return 'true'\n      if (object === false) return 'false'\n      if (object.an_instance_of) return 'an instance of ' + object.an_instance_of.name\n      if (object.jquery && object.selector.length > 0) return 'selector ' + puts(object.selector)\n      if (object.jquery) return object.get(0).outerHTML\n      if (object.nodeName) return object.outerHTML\n      switch (object.constructor) {\n        case Function: return object.name || object \n        case String: \n          return '\"' + object\n            .replace(/\"/g,  '\\\\\"')\n            .replace(/\\n/g, '\\\\n')\n            .replace(/\\t/g, '\\\\t')\n            + '\"'\n        case Array: \n          return inject(object, '[', function(b, v){\n            return b + ', ' + puts(v)\n          }).replace('[,', '[') + ' ]'\n        case Object:\n          object.__hit__ = true\n          return inject(object, '{', function(b, k, v) {\n            if (k == '__hit__') return b\n            return b + ', ' + k + ': ' + (v && v.__hit__ ? '<circular reference>' : puts(v))\n          }).replace('{,', '{') + ' }'\n        default: \n          return object.toString()\n      }\n    },\n\n    /**\n     * Parse an XML String and return a 'document'.\n     *\n     * @param {string} text\n     * @return {document}\n     * @api public\n     */\n\n    parseXML : function(text) {\n      var xmlDoc\n      if (window.DOMParser)\n        xmlDoc = (new DOMParser()).parseFromString(text, \"text/xml\")\n      else {\n        xmlDoc = new ActiveXObject(\"Microsoft.XMLDOM\")\n        xmlDoc.async = \"false\"\n        xmlDoc.loadXML(text)\n      }\n      return xmlDoc\n    },\n\n    /**\n     * Escape HTML.\n     *\n     * @param  {string} html\n     * @return {string}\n     * @api public\n     */\n\n     escape : function(html) {\n       return html.toString()\n         .replace(/&/gmi, '&amp;')\n         .replace(/\"/gmi, '&quot;')\n         .replace(/>/gmi, '&gt;')\n         .replace(/</gmi, '&lt;')\n     },\n     \n     /**\n      * Perform an assertion without reporting.\n      *\n      * This method is primarily used for internal\n      * matchers in order retain DRYness. May be invoked \n      * like below:\n      *\n      *   does('foo', 'eql', 'foo')\n      *   does([1,2], 'include', 1, 2)\n      *\n      * External hooks are not run for internal assertions\n      * performed by does().\n      *\n      * @param  {mixed} actual\n      * @param  {string} matcher\n      * @param  {...} expected\n      * @return {mixed}\n      * @api private\n      */\n     \n     does : function(actual, matcher, expected) {\n       var assertion = new JSpec.Assertion(JSpec.matchers[matcher], actual, toArray(arguments, 2))\n       return assertion.run().result\n     },\n\n    /**\n     * Perform an assertion.\n     *\n     *   expect(true).to('be', true)\n     *   expect('foo').not_to('include', 'bar')\n     *   expect([1, [2]]).to('include', 1, [2])\n     *\n     * @param  {mixed} actual\n     * @return {hash}\n     * @api public\n     */\n\n    expect : function(actual) {\n      function assert(matcher, args, negate) {\n        var expected = toArray(args, 1)\n        matcher.negate = negate  \n        var assertion = new JSpec.Assertion(matcher, actual, expected, negate)\n        hook('beforeAssertion', assertion)\n        if (matcher.defer) assertion.run()\n        else JSpec.currentSpec.assertions.push(assertion.run().report()), hook('afterAssertion', assertion)\n        return assertion.result\n      }\n      \n      function to(matcher) {\n        return assert(matcher, arguments, false)\n      }\n      \n      function not_to(matcher) {\n        return assert(matcher, arguments, true)\n      }\n      \n      return {\n        to : to,\n        should : to,\n        not_to: not_to,\n        should_not : not_to\n      }\n    },\n\n    /**\n     * Strim whitespace or chars.\n     *\n     * @param  {string} string\n     * @param  {string} chars\n     * @return {string}\n     * @api public\n     */\n\n     strip : function(string, chars) {\n       return string.\n         replace(new RegExp('['  + (chars || '\\\\s') + ']*$'), '').\n         replace(new RegExp('^[' + (chars || '\\\\s') + ']*'),  '')\n     },\n     \n     /**\n      * Call an iterator callback with arguments a, or b\n      * depending on the arity of the callback.\n      *\n      * @param  {function} callback\n      * @param  {mixed} a\n      * @param  {mixed} b\n      * @return {mixed}\n      * @api private\n      */\n     \n     callIterator : function(callback, a, b) {\n       return callback.length == 1 ? callback(b) : callback(a, b)\n     },\n     \n     /**\n      * Extend an object with another.\n      *\n      * @param  {object} object\n      * @param  {object} other\n      * @api public\n      */\n     \n     extend : function(object, other) {\n       each(other, function(property, value){\n         object[property] = value\n       })\n     },\n     \n     /**\n      * Iterate an object, invoking the given callback.\n      *\n      * @param  {hash, array} object\n      * @param  {function} callback\n      * @return {JSpec}\n      * @api public\n      */\n\n     each : function(object, callback) {\n       if (object.constructor == Array)\n         for (var i = 0, len = object.length; i < len; ++i)\n           callIterator(callback, i, object[i])\n       else\n         for (var key in object) \n           if (object.hasOwnProperty(key))\n             callIterator(callback, key, object[key])\n     },\n\n     /**\n      * Iterate with memo.\n      *\n      * @param  {hash, array} object\n      * @param  {object} memo\n      * @param  {function} callback\n      * @return {object}\n      * @api public\n      */\n\n     inject : function(object, memo, callback) {\n       each(object, function(key, value){\n         memo = (callback.length == 2 ?\n                   callback(memo, value):\n                     callback(memo, key, value)) ||\n                       memo\n       })\n       return memo\n     },\n     \n     /**\n      * Destub _object_'s _method_. When no _method_ is passed\n      * all stubbed methods are destubbed. When no arguments\n      * are passed every object found in JSpec.stubbed will be\n      * destubbed.\n      *\n      * @param  {mixed} object\n      * @param  {string} method\n      * @api public\n      */\n     \n     destub : function(object, method) {\n       var captures\n       if (method) {\n         if (object['__prototype__' + method])\n           delete object[method]\n         else\n           object[method] = object['__original__' + method]\n         delete object['__prototype__' + method]\n         delete object['__original____' + method]\n       }\n       else if (object) {\n         for (var key in object)\n           if (captures = key.match(/^(?:__prototype__|__original__)(.*)/))\n             destub(object, captures[1])\n       }\n       else\n         while (JSpec.stubbed.length)\n            destub(JSpec.stubbed.shift())\n     },\n     \n     /**\n      * Stub _object_'s _method_. \n      *\n      * stub(foo, 'toString').and_return('bar')\n      *\n      * @param  {mixed} object\n      * @param  {string} method\n      * @return {hash}\n      * @api public\n      */\n     \n     stub : function(object, method) {\n       hook('stubbing', object, method)\n       JSpec.stubbed.push(object)\n       var type = object.hasOwnProperty(method) ? '__original__' : '__prototype__'\n       object[type + method] = object[method]\n       object[method] = function(){}\n       return {\n         and_return : function(value) {\n           if (typeof value == 'function') object[method] = value\n           else object[method] = function(){ return value }\n         }\n      }\n     },\n     \n    /**\n     * Map callback return values.\n     *\n     * @param  {hash, array} object\n     * @param  {function} callback\n     * @return {array}\n     * @api public\n     */\n\n    map : function(object, callback) {\n      return inject(object, [], function(memo, key, value){\n        memo.push(callIterator(callback, key, value))\n      })\n    },\n    \n    /**\n     * Returns the first matching expression or null.\n     *\n     * @param  {hash, array} object\n     * @param  {function} callback\n     * @return {mixed}\n     * @api public\n     */\n         \n    any : function(object, callback) {\n      return inject(object, null, function(state, key, value){\n        if (state == undefined)\n          return callIterator(callback, key, value) ? value : state\n      })\n    },\n    \n    /**\n     * Returns an array of values collected when the callback\n     * given evaluates to true.\n     *\n     * @param  {hash, array} object\n     * @return {function} callback\n     * @return {array}\n     * @api public\n     */\n    \n    select : function(object, callback) {\n      return inject(object, [], function(selected, key, value){\n        if (callIterator(callback, key, value))\n          selected.push(value)\n      })\n    },\n\n    /**\n     * Define matchers.\n     *\n     * @param  {hash} matchers\n     * @api public\n     */\n\n    addMatchers : function(matchers) {\n      each(matchers, function(name, body){\n        JSpec.addMatcher(name, body)  \n      })\n    },\n    \n    /**\n     * Define a matcher.\n     *\n     * @param  {string} name\n     * @param  {hash, function, string} body\n     * @api public\n     */\n    \n    addMatcher : function(name, body) {\n      hook('addingMatcher', name, body)\n      if (name.indexOf(' ') != -1) {\n        var matchers = name.split(/\\s+/)\n        var prefix = matchers.shift()\n        each(matchers, function(name) {\n          JSpec.addMatcher(prefix + '_' + name, body(name))\n        })\n      }\n      this.matchers[name] = this.normalizeMatcherMessage(this.normalizeMatcherBody(body))\n      this.matchers[name].name = name\n    },\n    \n    /**\n     * Add a root suite to JSpec.\n     *\n     * @param  {string} description\n     * @param  {body} function\n     * @api public\n     */\n    \n    describe : function(description, body) {\n      var suite = new JSpec.Suite(description, body, false)\n      hook('addingSuite', suite)\n      this.allSuites.push(suite)\n      this.suites.push(suite)\n    },\n    \n    /**\n     * Add a shared example suite to JSpec.\n     *\n     * @param  {string} description\n     * @param  {body} function\n     * @api public\n     */\n    \n    shared_behaviors_for : function(description, body) {\n      var suite = new JSpec.Suite(description, body, true)\n      hook('addingSuite', suite)\n      this.allSuites.push(suite)\n      this.suites.push(suite)\n    },\n\n    /**\n     * Return the contents of a function body.\n     *\n     * @param  {function} body\n     * @return {string}\n     * @api public\n     */\n    \n    contentsOf : function(body) {\n      return body.toString().match(/^[^\\{]*{((.*\\n*)*)}/m)[1]\n    },\n\n    /**\n     * Evaluate a JSpec capture body.\n     *\n     * @param  {function} body\n     * @param  {string} errorMessage (optional)\n     * @return {Type}\n     * @api private\n     */\n\n    evalBody : function(body, errorMessage) {\n      var dsl = this.DSL || this.DSLs.snake\n      var matchers = this.matchers\n      var context = this.context || this.defaultContext\n      var contents = this.contentsOf(body)\n\t\t\thook('evaluatingBody', dsl, matchers, context, contents)\n      with (dsl){ with (context) { with (matchers) { eval(contents) }}}\n    },\n\n    /**\n     * Pre-process a string of JSpec.\n     *\n     * @param  {string} input\n     * @return {string}\n     * @api private\n     */\n\n    preprocess : function(input) {\n      if (typeof input != 'string') return\n      input = hookImmutable('preprocessing', input)\n      return input.\n        replace(/\\t/g, '  ').\n        replace(/\\r\\n|\\n|\\r/g, '\\n').\n        split('__END__')[0].\n        replace(/([\\w\\.]+)\\.(stub|destub)\\((.*?)\\)$/gm, '$2($1, $3)').\n        replace(/describe\\s+(.*?)$/gm, 'describe($1, function(){').\n        replace(/shared_behaviors_for\\s+(.*?)$/gm, 'shared_behaviors_for($1, function(){').\n        replace(/^\\s+it\\s+(.*?)$/gm, ' it($1, function(){').\n\t\t\t\treplace(/^ *(before_nested|after_nested|before_each|after_each|before|after)(?= |\\n|$)/gm, 'JSpec.currentSuite.addHook(\"$1\", function(){').\n        replace(/^\\s*end(?=\\s|$)/gm, '});').\n        replace(/-\\{/g, 'function(){').\n        replace(/(\\d+)\\.\\.(\\d+)/g, function(_, a, b){ return range(a, b) }).\n        replace(/\\.should([_\\.]not)?[_\\.](\\w+)(?: |;|$)(.*)$/gm, '.should$1_$2($3)').\n        replace(/([\\/\\s]*)(.+?)\\.(should(?:[_\\.]not)?)[_\\.](\\w+)\\((.*)\\)\\s*;?$/gm, '$1 expect($2).$3($4, $5)').\n        replace(/, \\)/g, ')').\n        replace(/should\\.not/g, 'should_not')\n    },\n\n    /**\n     * Create a range string which can be evaluated to a native array.\n     *\n     * @param  {int} start\n     * @param  {int} end\n     * @return {string}\n     * @api public\n     */\n\n    range : function(start, end) {\n      var current = parseInt(start), end = parseInt(end), values = [current]\n      if (end > current) while (++current <= end) values.push(current)\n      else               while (--current >= end) values.push(current)\n      return '[' + values + ']'\n    },\n\n    /**\n     * Report on the results. \n     *\n     * @api public\n     */\n\n    report : function() {\n      this.duration = Number(new Date) - this.start\n      hook('reporting', JSpec.options)\n      new (JSpec.options.reporter || JSpec.reporters.DOM)(JSpec, JSpec.options)\n    },\n\n    /**\n     * Run the spec suites. Options are merged\n     * with JSpec options when present.\n     *\n     * @param  {hash} options\n     * @return {JSpec}\n     * @api public\n     */\n\n    run : function(options) {\n      if (any(hook('running'), haveStopped)) return this\n      if (options) extend(this.options, options)\n      this.start = Number(new Date)\n      each(this.suites, function(suite) { JSpec.runSuite(suite) })\n      return this\n    },\n    \n    /**\n     * Run a suite.\n     *\n     * @param  {Suite} suite\n     * @api public\n     */\n\n    runSuite : function(suite) {\n\t\t\tif (!suite.isShared())\n\t\t\t{\n\t      this.currentSuite = suite\n\t      this.evalBody(suite.body)\n\t      suite.ran = true\n\t      hook('beforeSuite', suite), suite.hook('before'), suite.hook('before_nested')\n\t      each(suite.specs, function(spec) {\n\t        hook('beforeSpec', spec)\n\t        suite.hook('before_each')\n\t        JSpec.runSpec(spec)\n\t        hook('afterSpec', spec)\n\t        suite.hook('after_each')\n\t      })\n\t      if (suite.hasSuites()) {\n\t        each(suite.suites, function(suite) {\n\t          JSpec.runSuite(suite)\n\t        })\n\t      }\n\t      hook('afterSuite', suite), suite.hook('after_nested'), suite.hook('after')\n\t      this.stats.suitesFinished++\n\t\t\t}\t\n\t\t},\n         \n    /**\n     * Report a failure for the current spec.\n     *\n     * @param  {string} message\n     * @api public\n     */\n     \n     fail : function(message) {\n       JSpec.currentSpec.fail(message)\n     },\n     \n     /**\n      * Report a passing assertion for the current spec.\n      *\n      * @param  {string} message\n      * @api public\n      */\n      \n     pass : function(message) {\n       JSpec.currentSpec.pass(message)\n     },\n\n    /**\n     * Run a spec.\n     *\n     * @param  {Spec} spec\n     * @api public\n     */\n\n    runSpec : function(spec) {\n      this.currentSpec = spec\n      try { this.evalBody(spec.body) }\n      catch (e) { fail(e) }\n      spec.runDeferredAssertions()\n      destub()\n      this.stats.specsFinished++\n      this.stats.assertions += spec.assertions.length\n    },\n\n    /**\n     * Require a dependency, with optional message.\n     *\n     * @param  {string} dependency\n     * @param  {string} message (optional)\n     * @return {JSpec}\n     * @api public\n     */\n\n    requires : function(dependency, message) {\n      hook('requiring', dependency, message)\n      try { eval(dependency) }\n      catch (e) { throw 'JSpec depends on ' + dependency + ' ' + message }\n      return this\n    },\n\n    /**\n     * Query against the current query strings keys\n     * or the queryString specified.\n     *\n     * @param  {string} key\n     * @param  {string} queryString\n     * @return {string, null}\n     * @api private\n     */\n\n    query : function(key, queryString) {\n      var queryString = (queryString || (main.location ? main.location.search : null) || '').substring(1)\n      return inject(queryString.split('&'), null, function(value, pair){\n        parts = pair.split('=')\n        return parts[0] == key ? parts[1].replace(/%20|\\+/gmi, ' ') : value\n      })\n    },\n\n    /**\n     * Ad-hoc POST request for JSpec server usage.\n     *\n     * @param  {string} uri\n     * @param  {string} data\n     * @api private\n     */\n    \n    post : function(uri, data) {\n      if (any(hook('posting', uri, data), haveStopped)) return\n      var request = this.xhr()\n      request.open('POST', uri, false)\n      request.setRequestHeader('Content-Type', 'application/json')\n      request.send(JSpec.JSON.encode(data))\n    },\n\n    /**\n     * Instantiate an XMLHttpRequest.\n     *\n     * Here we utilize IE's lame ActiveXObjects first which\n     * allow IE access serve files via the file: protocol, otherwise\n     * we then default to XMLHttpRequest.\n     *\n     * @return {XMLHttpRequest, ActiveXObject}\n     * @api private\n     */\n    \n    xhr : function() {\n      return this.ieXhr() || new JSpec.request\n    },\n    \n    /**\n     * Return Microsoft piece of crap ActiveXObject.\n     *\n     * @return {ActiveXObject}\n     * @api public\n     */\n    \n    ieXhr : function() {\n      function object(str) {\n        try { return new ActiveXObject(str) } catch(e) {}\n      }\n      return object('Msxml2.XMLHTTP.6.0') ||\n        object('Msxml2.XMLHTTP.3.0') ||\n        object('Msxml2.XMLHTTP') ||\n        object('Microsoft.XMLHTTP')\n    },\n    \n    /**\n     * Check for HTTP request support.\n     *\n     * @return {bool}\n     * @api private\n     */\n    \n    hasXhr : function() {\n      return JSpec.request || 'ActiveXObject' in main\n    },\n    \n    /**\n     * Try loading _file_ returning the contents\n     * string or null. Chain to locate / read a file.\n     *\n     * @param  {string} file\n     * @return {string}\n     * @api public\n     */\n    \n    tryLoading : function(file) {\n      try { return JSpec.load(file) } catch (e) {}\n    },\n\n    /**\n     * Load a _file_'s contents.\n     *\n     * @param  {string} file\n     * @param  {function} callback\n     * @return {string}\n     * @api public\n     */\n\n    load : function(file, callback) {\n      if (any(hook('loading', file), haveStopped)) return\n      if ('readFile' in main)\n        return readFile(file)\n      else if (this.hasXhr()) {\n        var request = this.xhr()\n        request.open('GET', file, false)\n        request.send(null)\n        if (request.readyState == 4 && \n           (request.status == 0 || \n            request.status.toString().charAt(0) == 2)) \n          return request.responseText\n      }\n      else\n        throw new Error(\"failed to load `\" + file + \"'\")\n    },\n\n    /**\n     * Load, pre-process, and evaluate a file.\n     *\n     * @param {string} file\n     * @param {JSpec}\n     * @api public\n     */\n\n    exec : function(file) {\n      if (any(hook('executing', file), haveStopped)) return this\n      eval('with (JSpec){' + this.preprocess(this.load(file)) + '}')\n      return this\n    }\n  }\n  \n  // --- Node.js support\n  \n  if (typeof GLOBAL === 'object' && typeof exports === 'object') {\n    var fs = require('fs')\n    quit = process.exit\n    print = require('sys').puts\n    readFile = function(file){\n      return fs.readFileSync(file).toString('utf8')\n    }\n  }\n  \n  // --- Utility functions\n\n  var main = this,\n      find = JSpec.any,\n      utils = 'haveStopped stub hookImmutable hook destub map any last pass fail range each option inject select \\\n               error escape extend puts query strip color does addMatchers callIterator toArray equal'.split(/\\s+/)\n  while (utils.length) eval('var ' + utils[0] + ' = JSpec.' + utils.shift())\n  if (!main.setTimeout) main.setTimeout = function(callback){ callback() }\n\n  // --- Matchers\n\n  addMatchers({\n    equal              : \"===\",\n    eql                : \"equal(actual, expected)\",\n    be                 : \"alias equal\",\n    be_greater_than    : \">\",\n    be_less_than       : \"<\",\n    be_at_least        : \">=\",\n    be_at_most         : \"<=\",\n    be_a               : \"actual.constructor == expected\",\n    be_an              : \"alias be_a\",\n    be_an_instance_of  : \"actual instanceof expected\",\n    be_null            : \"actual == null\",\n    be_true            : \"actual == true\",\n    be_false           : \"actual == false\",\n    be_undefined       : \"typeof actual == 'undefined'\",\n    be_type            : \"typeof actual == expected\",\n    match              : \"typeof actual == 'string' ? actual.match(expected) : false\",\n    respond_to         : \"typeof actual[expected] == 'function'\",\n    have_length        : \"actual.length == expected\",\n    be_within          : \"actual >= expected[0] && actual <= last(expected)\",\n    have_length_within : \"actual.length >= expected[0] && actual.length <= last(expected)\",\n    \n    receive : { defer : true, match : function(actual, method, times) {\n      var proxy = new JSpec.ProxyAssertion(actual, method, times, this.negate)\n      JSpec.currentSpec.assertions.push(proxy)\n      return proxy\n    }},\n    \n    be_empty : function(actual) {\n      if (actual.constructor == Object && actual.length == undefined)\n        for (var key in actual)\n          return false;\n      return !actual.length\n    },\n\n    include : function(actual) {\n      for (var state = true, i = 1; i < arguments.length; i++) {\n        var arg = arguments[i]\n        switch (actual.constructor) {\n          case String: \n          case Number:\n          case RegExp:\n          case Function:\n            state = actual.toString().indexOf(arg) !== -1\n            break\n         \n          case Object:\n            state = arg in actual\n            break\n          \n          case Array: \n            state = any(actual, function(value){ return equal(value, arg) })\n            break\n        }\n        if (!state) return false\n      }\n      return true\n    },\n\n    throw_error : { match : function(actual, expected, message) {\n      try { actual() }\n      catch (e) {\n        this.e = e\n        var assert = function(arg) {\n          switch (arg.constructor) {\n            case RegExp   : return arg.test(e.message || e.toString())\n            case String   : return arg == (e.message || e.toString())\n            case Function : return e instanceof arg || e.name == arg.name\n          }\n        }\n        return message ? assert(expected) && assert(message) :\n                 expected ? assert(expected) :\n                   true\n      }\n    }, message : function(actual, expected, negate) {\n      // TODO: refactor when actual is not in expected [0]\n      var message_for = function(i) {\n        if (expected[i] == undefined) return 'exception'\n        switch (expected[i].constructor) {\n          case RegExp   : return 'exception matching ' + puts(expected[i])\n          case String   : return 'exception of ' + puts(expected[i])\n          case Function : return expected[i].name || 'Error'\n        }\n      }\n      var exception = message_for(1) + (expected[2] ? ' and ' + message_for(2) : '')\n      return 'expected ' + exception + (negate ? ' not ' : '' ) +\n               ' to be thrown, but ' + (this.e ? 'got ' + puts(this.e) : 'nothing was')\n    }},\n    \n    have : function(actual, length, property) {\n      return actual[property] == null ? false : actual[property].length == length\n    },\n    \n    have_at_least : function(actual, length, property) {\n      return actual[property] == null ? (length === 0) : actual[property].length >= length\n    },\n    \n    have_at_most :function(actual, length, property) {\n      return actual[property] == null || actual[property].length <= length\n    },\n    \n    have_within : function(actual, range, property) {\n      var length = actual[property] == undefined ? 0 : actual[property].length\n      return length >= range.shift() && length <= range.pop()\n    },\n    \n    have_prop : function(actual, property, value) {\n      var actualVal = actual[property], actualType = typeof actualVal\n      return (actualType == 'function' || actualType == 'undefined') ? false :\n        typeof value === 'undefined' ||\n        does(actual[property],'eql',value)\n    },\n    \n    have_property : function(actual, property, value) {\n      var actualVal = actual[property], actualType = typeof actualVal\n      return (actualType == 'function' || actualType == 'undefined') ? false :\n        typeof value === 'undefined' ||\n        value === actualVal\n    }\n  })\n  \n})()\n","/home/travis/build/npmtest/node-npmtest-sass/node_modules/sass/spec/lib/jspec.nodejs.js":"\n// JSpec - node - Copyright TJ Holowaychuk <tj@vision-media.ca> (MIT Licensed)\n\nJSpec\n.include({\n  name: 'node',\n  \n  // --- Matchers\n  \n  matchers : {\n    have_enumerable_property: 'actual.propertyIsEnumerable(expected)',\n    have_writable_property: 'Object.getOwnPropertyDescriptor(actual, expected).writable === true',\n    have_configurable_property: 'Object.getOwnPropertyDescriptor(actual, expected).configurable === true',\n    have_keys: 'does(Object.keys(actual), \"eql\", expected)',\n    have_prototype: 'Object.getPrototypeOf(actual) === expected'\n  }\n})\n\n","/home/travis/build/npmtest/node-npmtest-sass/node_modules/sass/spec/lib/jspec.shell.js":"\n// JSpec - Shell - Copyright TJ Holowaychuk <tj@vision-media.ca> (MIT Licensed)\n\n;(function(){\n  \n  var _quit = quit\n  \n  Shell = {\n    \n    // --- Global\n    \n    main: this,\n    \n    // --- Commands\n    \n    commands: {\n      quit: ['Terminate the shell', function(){ _quit() }],\n      exit: ['Terminate the shell', function(){ _quit() }],\n      p: ['Inspect an object', function(o){ return o.toSource() }]\n    },\n    \n    /**\n     * Start the interactive shell.\n     *\n     * @api public\n     */\n    \n    start : function() {\n      for (var name in this.commands)\n        if (this.commands.hasOwnProperty(name))\n          this.commands[name][1].length ?\n            this.main[name] = this.commands[name][1] :\n              this.main.__defineGetter__(name, this.commands[name][1])\n    }\n  }\n  \n  Shell.start()\n  \n})()","/home/travis/build/npmtest/node-npmtest-sass/node_modules/sass/spec/lib/jspec.timers.js":"\n// JSpec - Mock Timers - Copyright TJ Holowaychuk <tj@vision-media.ca> (MIT Licensed)\n\n;(function(){\n  \n  /**\n   * Version.\n   */\n   \n  mockTimersVersion = '1.0.2'\n  \n  /**\n   * Localized timer stack.\n   */\n  \n  var timers = []\n  \n  /**\n   * Set mock timeout with _callback_ and timeout of _ms_.\n   *\n   * @param  {function} callback\n   * @param  {int} ms\n   * @return {int}\n   * @api public\n   */\n  \n  setTimeout = function(callback, ms) {\n    var id\n  \treturn id = setInterval(function(){\n  \t  callback()\n  \t  clearInterval(id)\n  \t}, ms)\n  }\n  \n  /**\n   * Set mock interval with _callback_ and interval of _ms_.\n   *\n   * @param  {function} callback\n   * @param  {int} ms\n   * @return {int}\n   * @api public\n   */\n\n  setInterval = function(callback, ms) {\n    callback.step = ms, callback.current = callback.last = 0\n    return timers[timers.length] = callback, timers.length\n  }\n  \n  /**\n   * Destroy timer with _id_.\n   *\n   * @param  {int} id\n   * @return {bool}\n   * @api public\n   */\n\n  clearInterval = clearTimeout = function(id) {\n    return delete timers[--id]\n  }\n  \n  /**\n   * Reset timers.\n   *\n   * @return {array}\n   * @api public\n   */\n  \n  resetTimers = function() {\n    return timers = []\n  }\n  \n  /**\n   * Increment each timers internal clock by _ms_.\n   *\n   * @param  {int} ms\n   * @api public\n   */\n  \n  tick = function(ms) {\n    for (var i = 0, len = timers.length; i < len; ++i)\n      if (timers[i] && (timers[i].current += ms))\n        if (timers[i].current - timers[i].last >= timers[i].step) {\n          var times = Math.floor((timers[i].current - timers[i].last) / timers[i].step)\n          var remainder = (timers[i].current - timers[i].last) % timers[i].step\n          timers[i].last = timers[i].current - remainder\n          while (times-- && timers[i]) timers[i]()\n        }\n  }\n  \n})()","/home/travis/build/npmtest/node-npmtest-sass/node_modules/sass/spec/lib/jspec.xhr.js":"\n// JSpec - XHR - Copyright TJ Holowaychuk <tj@vision-media.ca> (MIT Licensed)\n\n(function(){\n\n  var lastRequest\n\n  // --- Original XMLHttpRequest\n\n  var OriginalXMLHttpRequest = 'XMLHttpRequest' in this ?\n                                 XMLHttpRequest :\n                                   function(){}\n  var OriginalActiveXObject = 'ActiveXObject' in this ?\n                                 ActiveXObject :\n                                   undefined\n\n  // --- MockXMLHttpRequest\n\n  var MockXMLHttpRequest = function() {\n    this.requestHeaders = {}\n  }\n\n  MockXMLHttpRequest.prototype = {\n    status: 0,\n    async: true,\n    readyState: 0,\n\t  responseXML: null,\n    responseText: '',\n    abort: function(){},\n    onreadystatechange: function(){},\n\n   /**\n    * Return response headers hash.\n    */\n\n    getAllResponseHeaders : function(){\n      return JSpec.inject(this.responseHeaders, '', function(buf, key, val){\n        return buf + key + ': ' + val + '\\r\\n'\n      })\n    },\n\n    /**\n     * Return case-insensitive value for header _name_.\n     */\n\n    getResponseHeader : function(name) {\n      return this.responseHeaders[name.toLowerCase()]\n    },\n\n    /**\n     * Set case-insensitive _value_ for header _name_.\n     */\n\n    setRequestHeader : function(name, value) {\n      this.requestHeaders[name.toLowerCase()] = value\n    },\n\n    /**\n     * Open mock request.\n     */\n\n    open : function(method, url, async, user, password) {\n      this.user = user\n      this.password = password\n      this.url = url\n      this.readyState = 1\n      this.method = method.toUpperCase()\n      if (async != undefined) this.async = async\n      if (this.async) this.onreadystatechange()\n    },\n\n    /**\n     * Send request _data_.\n     */\n\n    send : function(data) {\n      var self = this\n      this.data = data\n      this.readyState = 4\n      if (this.method == 'HEAD') this.responseText = null\n      this.responseHeaders['content-length'] = (this.responseText || '').length\n      if(this.async) this.onreadystatechange()\n\t    this.populateResponseXML()\n      lastRequest = function(){\n        return self\n      }\n    },\n\n\t/**\n\t * Parse request body and populate responseXML if response-type is xml\n\t * Based on the standard specification : http://www.w3.org/TR/XMLHttpRequest/\n\t */\n\tpopulateResponseXML: function() {\n\t\tvar type = this.getResponseHeader(\"content-type\")\n\t\tif (!type || !this.responseText || !type.match(/(text\\/xml|application\\/xml|\\+xml$)/g))\n\t\t\treturn\n\t\tthis.responseXML = JSpec.parseXML(this.responseText)\n\t  }\n  }\n\n  // --- Response status codes\n\n  JSpec.statusCodes = {\n    100: 'Continue',\n    101: 'Switching Protocols',\n    200: 'OK',\n    201: 'Created',\n    202: 'Accepted',\n    203: 'Non-Authoritative Information',\n    204: 'No Content',\n    205: 'Reset Content',\n    206: 'Partial Content',\n    300: 'Multiple Choice',\n    301: 'Moved Permanently',\n    302: 'Found',\n    303: 'See Other',\n    304: 'Not Modified',\n    305: 'Use Proxy',\n    307: 'Temporary Redirect',\n    400: 'Bad Request',\n    401: 'Unauthorized',\n    402: 'Payment Required',\n    403: 'Forbidden',\n    404: 'Not Found',\n    405: 'Method Not Allowed',\n    406: 'Not Acceptable',\n    407: 'Proxy Authentication Required',\n    408: 'Request Timeout',\n    409: 'Conflict',\n    410: 'Gone',\n    411: 'Length Required',\n    412: 'Precondition Failed',\n    413: 'Request Entity Too Large',\n    414: 'Request-URI Too Long',\n    415: 'Unsupported Media Type',\n    416: 'Requested Range Not Satisfiable',\n    417: 'Expectation Failed',\n    422: 'Unprocessable Entity',\n    500: 'Internal Server Error',\n    501: 'Not Implemented',\n    502: 'Bad Gateway',\n    503: 'Service Unavailable',\n    504: 'Gateway Timeout',\n    505: 'HTTP Version Not Supported'\n  }\n\n  /**\n   * Mock XMLHttpRequest requests.\n   *\n   *   mockRequest().and_return('some data', 'text/plain', 200, { 'X-SomeHeader' : 'somevalue' })\n   *\n   * @return {hash}\n   * @api public\n   */\n\n  function mockRequest() {\n    return { and_return : function(body, type, status, headers) {\n      XMLHttpRequest = MockXMLHttpRequest\n      ActiveXObject = false\n      status = status || 200\n      headers = headers || {}\n      headers['content-type'] = type\n      JSpec.extend(XMLHttpRequest.prototype, {\n        responseText: body,\n        responseHeaders: headers,\n        status: status,\n        statusText: JSpec.statusCodes[status]\n      })\n    }}\n  }\n\n  /**\n   * Unmock XMLHttpRequest requests.\n   *\n   * @api public\n   */\n\n  function unmockRequest() {\n    XMLHttpRequest = OriginalXMLHttpRequest\n    ActiveXObject = OriginalActiveXObject\n  }\n\n  JSpec.include({\n    name: 'Mock XHR',\n\n    // --- Utilities\n\n    utilities : {\n      mockRequest: mockRequest,\n      unmockRequest: unmockRequest\n    },\n\n    // --- Hooks\n\n    afterSpec : function() {\n      unmockRequest()\n    },\n\n    // --- DSLs\n\n    DSLs : {\n      snake : {\n        mock_request: mockRequest,\n        unmock_request: unmockRequest,\n        last_request: function(){ return lastRequest() }\n      }\n    }\n\n  })\n})()\n"}